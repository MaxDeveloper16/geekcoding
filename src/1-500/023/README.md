# 题目
## Merge k Sorted Lists
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6

# 级别
Hard

# 算法口号
heapq 压栈

# 解题思路
每次需要用的是K个链表头结点的最小值，所以把每个链表的头结点都放在一个小根堆里面。这样，每次弹出来的就是最小链表的值，然后根据这个值的索引去Lists中找到对应节点，拼接到末尾就行。

有人使用的弹出堆里面最小的值，然后重新生成新的节点的方式，这样不好。

另外，代码里需要注意的一个问题是，和方法一一样，需要更新链表的头结点才行，不能直接通过修改指针的方式修改，必须直接赋值更新。如果这个步骤少了的话，按照索引查找就一直获取的是老节点。

时间复杂度是O(N)，空间复杂度是O(1)。N是结果链表的长度，K是每次题目给出的链表个数。